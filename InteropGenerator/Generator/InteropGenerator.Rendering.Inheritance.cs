using System.Collections.Immutable;
using InteropGenerator.Helpers;
using InteropGenerator.Models;

namespace InteropGenerator.Generator;

public sealed partial class InteropGenerator {
    private static string RenderInheritedStructInfo(StructInfo structInfo, ImmutableArray<StructInfo> inheritedStructs, CancellationToken token) {
        using IndentedTextWriter writer = new();

        // write file header
        writer.WriteLine("// <auto-generated/>");

        // write namespace 
        if (structInfo.Namespace.Length > 0) {
            writer.WriteLine($"namespace {structInfo.Namespace};");
            writer.WriteLine();
        }

        // write opening struct hierarchy in reverse order
        // note we do not need to specify the accessibility here since a partial declared with no accessibility uses the other partial
        for (int i = structInfo.Hierarchy.Length - 1; i >= 0; i--) {
            writer.WriteLine($"unsafe partial struct {structInfo.Hierarchy[i]}");
            writer.WriteLine("{");
            writer.IncreaseIndent();
        }

        if (inheritedStructs.Any())
            RenderInheritance(structInfo, inheritedStructs, token, writer);

        // write closing struct hierarchy
        for (var i = 0; i < structInfo.Hierarchy.Length; i++) {
            writer.DecreaseIndent();
            writer.WriteLine("}");
        }

        return writer.ToString();
    }
    private static void RenderInheritance(StructInfo structInfo, ImmutableArray<StructInfo> inheritedStructs, CancellationToken token, IndentedTextWriter writer) {
        // resolve the list of inherited structs and their offsets
        using ImmutableArrayBuilder<(StructInfo inheritedStruct, string path, int offset)> resolvedInheritanceOrderBuilder = new();

        var hasPrimaryVirtualFunctions = false;

        ResolveInheritanceOrder(structInfo, string.Empty, 0, 0, 0, inheritedStructs, resolvedInheritanceOrderBuilder, ref hasPrimaryVirtualFunctions);

        ImmutableArray<(StructInfo inheritedStruct, string path, int offset)> resolvedInheritanceOrder = resolvedInheritanceOrderBuilder.ToImmutable();

        token.ThrowIfCancellationRequested();

        HashSet<string> alreadyWrittenParents = new();
        HashSet<string> alreadyWrittenBases = new();

        // inherited fields
        foreach ((StructInfo inheritedStruct, string path, int offset) in resolvedInheritanceOrder) {
            // write parent accessor if its directly inherited
            if (structInfo.InheritedStructs.Any(inheritanceInfo => inheritanceInfo.InheritedTypeName == inheritedStruct.FullyQualifiedMetadataName)
                && !alreadyWrittenParents.Contains(inheritedStruct.FullyQualifiedMetadataName)) {
                string fieldName = inheritedStruct.Name;
                if (inheritedStruct.Name == structInfo.Name)
                    fieldName = inheritedStruct.Name + "Base";
                writer.WriteLine($"""/// <summary>Inherited parent class accessor for <see cref="{inheritedStruct.FullyQualifiedMetadataName}">{inheritedStruct.Name}</see></summary>""");
                writer.WriteLine($"[global::System.Runtime.InteropServices.FieldOffsetAttribute({offset})] public {inheritedStruct.FullyQualifiedMetadataName} {fieldName};");
                alreadyWrittenParents.Add(inheritedStruct.FullyQualifiedMetadataName);
            }
            // write public fields
            foreach (FieldInfo field in inheritedStruct.ExtraInheritedStructInfo!.PublicFields) {
                string adjustedFieldName = alreadyWrittenBases.Contains(inheritedStruct.FullyQualifiedMetadataName) ? $"{path.Replace(".", "_")}_{field.Name}" : field.Name;
                writer.WriteLine($"""/// <inheritdoc cref="{inheritedStruct.FullyQualifiedMetadataName}.{field.Name}" />""");
                writer.WriteLine($"""/// <remarks>Field inherited from parent class <see cref="{inheritedStruct.FullyQualifiedMetadataName}">{inheritedStruct.Name}</see>.</remarks>""");
                writer.WriteLine($"[global::System.Runtime.InteropServices.FieldOffsetAttribute({offset + field.Offset})] public {field.Type} {adjustedFieldName};");
            }
            alreadyWrittenBases.Add(inheritedStruct.FullyQualifiedMetadataName);
        }

        token.ThrowIfCancellationRequested();

        // inherited member functions
        foreach ((StructInfo inheritedStruct, string path, _) in resolvedInheritanceOrder) {
            if (!inheritedStruct.MemberFunctions.IsEmpty)
                RenderInheritedMemberFunctions(inheritedStruct, path, writer);
        }

        token.ThrowIfCancellationRequested();

        // add entries to the main virtual table for the primary inheritance chain
        if (hasPrimaryVirtualFunctions)
            RenderInheritedVirtualTable(structInfo, resolvedInheritanceOrder, writer);
        
        // render delegates for primary inherited virtual table functions
        if (hasPrimaryVirtualFunctions)
            RenderInheritedDelegateTypes(structInfo, resolvedInheritanceOrder, writer);

        // inherited virtual function bodies
        foreach ((StructInfo inheritedStruct, string path, int offset) in resolvedInheritanceOrder) {
            if (!inheritedStruct.VirtualFunctions.IsEmpty)
                RenderInheritedVirtualFunctions(structInfo.Name, inheritedStruct, path, offset, writer);
        }

        token.ThrowIfCancellationRequested();

        // inherited public methods
        foreach ((StructInfo inheritedStruct, string path, _) in resolvedInheritanceOrder) {
            if (!inheritedStruct.ExtraInheritedStructInfo!.PublicMethods.IsEmpty)
                RenderInheritedPublicMethods(inheritedStruct, path, writer);
        }

        token.ThrowIfCancellationRequested();

        // inherited string overloads
        // we can just use the regular renderer here since the overloaded function should also be inherited
        foreach ((StructInfo inheritedStruct, _, _) in resolvedInheritanceOrder) {
            if (!inheritedStruct.StringOverloads.IsEmpty)
                RenderStringOverloads(inheritedStruct, writer);
        }

        token.ThrowIfCancellationRequested();

        // inherited fixed array accessors
        foreach ((StructInfo inheritedStruct, string path, _) in resolvedInheritanceOrder) {
            if (!inheritedStruct.FixedSizeArrays.IsEmpty)
                RenderInheritedFixedSizeArrayAccessors(inheritedStruct, path, writer);
        }

        token.ThrowIfCancellationRequested();
    }
    private static int ResolveInheritanceOrder(StructInfo structInfo, string path, int absoluteOffset, int curParentOffset, int index, ImmutableArray<StructInfo> inheritedStructs, ImmutableArrayBuilder<(StructInfo inheritedStruct, string path, int offset)> resolvedInheritanceOrder, ref bool hasPrimaryVirtualFunctions) {
        var processed = 0;
        foreach (InheritanceInfo inheritanceInfo in structInfo.InheritedStructs) {
            // failure earlier in generator, haven't collected all inherited structs
            if (index >= inheritedStructs.Length) {
                return 0;
            }

            if (inheritanceInfo.ParentOffset != 0)
                absoluteOffset = curParentOffset + inheritanceInfo.ParentOffset;

            StructInfo currentStruct = inheritedStructs[index + processed];
            string baseName = structInfo.Name == currentStruct.Name ? currentStruct.Name + "Base" : currentStruct.Name;
            string newPath = path == string.Empty ? baseName : path + "." + baseName;

            processed += 1;

            processed += ResolveInheritanceOrder(currentStruct, newPath, absoluteOffset, absoluteOffset, index + processed, inheritedStructs, resolvedInheritanceOrder, ref hasPrimaryVirtualFunctions);

            resolvedInheritanceOrder.Add((currentStruct, newPath, absoluteOffset));
            if (absoluteOffset == 0 && !currentStruct.VirtualFunctions.IsEmpty)
                hasPrimaryVirtualFunctions = true;

            absoluteOffset += currentStruct.ExtraInheritedStructInfo!.Size;
        }
        return processed;
    }

    private static void RenderInheritedMemberFunctions(StructInfo inheritedStruct, string path, IndentedTextWriter writer) {
        foreach (MemberFunctionInfo memberFunctionInfo in inheritedStruct.MemberFunctions) {
            if (memberFunctionInfo.MethodInfo.Name == "Ctor")
                continue;
            MethodInfo methodInfo = memberFunctionInfo.MethodInfo;
            writer.WriteLine($"""/// <inheritdoc cref="{inheritedStruct.FullyQualifiedMetadataName}.{methodInfo.Name}({methodInfo.GetParameterTypeStringForCref()})" />""");
            writer.WriteLine($"""/// <remarks>Method inherited from parent class <see cref="{inheritedStruct.FullyQualifiedMetadataName}">{inheritedStruct.Name}</see>.</remarks>""");
            writer.WriteLine("[global::System.Runtime.CompilerServices.MethodImplAttribute(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]");
            // public int SomeInheritedMethod(int param, int param2) => Path.To.Parent.SomeInheritedMethod(param, param2);
            writer.WriteLine($"{methodInfo.GetDeclarationStringWithoutPartial()} => {path}.{methodInfo.Name}({methodInfo.GetParameterNamesString()});");
        }
    }

    private static void RenderInheritedVirtualTable(StructInfo structInfo, ImmutableArray<(StructInfo inheritedStruct, string path, int offset)> resolvedInheritanceOrder, IndentedTextWriter writer) {
        // write virtual function pointers from inherited structs using the child struct type as the "this" pointer
        // StructLayout can't be duplicated so only write it if it hasnt been written before
        if (!structInfo.HasVirtualTable())
            writer.WriteLine("[global::System.Runtime.InteropServices.StructLayoutAttribute(global::System.Runtime.InteropServices.LayoutKind.Explicit)]");
        writer.WriteLine($"public unsafe partial struct {structInfo.Name}VirtualTable");
        using (writer.WriteBlock()) {
            foreach ((StructInfo inheritedStruct, _, int offset) in resolvedInheritanceOrder) {
                // only inherited structs at offset 0 are the primary inheritance chain that make up the main virtual table
                if (offset != 0)
                    continue;
                foreach (VirtualFunctionInfo virtualFunctionInfo in inheritedStruct.VirtualFunctions) {
                    var functionPointerType = $"delegate* unmanaged <{structInfo.Name}*, {virtualFunctionInfo.MethodInfo.GetParameterTypeStringWithTrailingType()}{virtualFunctionInfo.MethodInfo.ReturnType}>";
                    writer.WriteLine($"[global::System.Runtime.InteropServices.FieldOffsetAttribute({virtualFunctionInfo.Index * 8})] public {functionPointerType} {virtualFunctionInfo.MethodInfo.Name};");
                }
            }
        }
        // if the only virtual functions were inherited we need to write the vtable accessor
        if (!structInfo.HasVirtualTable()) {
            writer.WriteLine($"[global::System.Runtime.InteropServices.FieldOffsetAttribute(0)] public {structInfo.Name}VirtualTable* VirtualTable;");
        }
    }
    
    private static void RenderInheritedDelegateTypes(StructInfo structInfo, ImmutableArray<(StructInfo inheritedStruct, string path, int offset)> resolvedInheritanceOrder, IndentedTextWriter writer) {
        writer.WriteLine($"public static partial class Delegates");
        using (writer.WriteBlock()) {
            foreach ((StructInfo inheritedStruct, _, int offset) in resolvedInheritanceOrder) {
                // only inherited structs at offset 0 are the primary inheritance chain that make up the main virtual table
                if (offset != 0)
                    continue;
                foreach (VirtualFunctionInfo virtualFunctionInfo in inheritedStruct.VirtualFunctions) {
                    RenderDelegateTypeForMethod(structInfo.Name, virtualFunctionInfo.MethodInfo, writer);
                }
            }
        }
    }

    private static void RenderInheritedVirtualFunctions(string childTypeName, StructInfo inheritedStruct, string path, int offset, IndentedTextWriter writer) {
        foreach (VirtualFunctionInfo virtualFunctionInfo in inheritedStruct.VirtualFunctions) {
            MethodInfo methodInfo = virtualFunctionInfo.MethodInfo;
            if (offset != 0 && methodInfo.Name == "Dtor") continue;
            writer.WriteLine($"""/// <inheritdoc cref="{inheritedStruct.FullyQualifiedMetadataName}.{methodInfo.Name}({methodInfo.GetParameterTypeStringForCref()})" />""");
            writer.WriteLine($"""/// <remarks>Method inherited from parent class <see cref="{inheritedStruct.FullyQualifiedMetadataName}">{inheritedStruct.Name}</see>.</remarks>""");
            writer.WriteLine("[global::System.Runtime.CompilerServices.MethodImplAttribute(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]");
            // function in table - call via table
            if (offset == 0) {
                var paramNames = string.Empty;
                if (methodInfo.Parameters.Any())
                    paramNames = ", " + methodInfo.GetParameterNamesString();
                writer.WriteLine($"{methodInfo.GetDeclarationStringWithoutPartial()} => VirtualTable->{methodInfo.Name}(({childTypeName}*)global::System.Runtime.CompilerServices.Unsafe.AsPointer(ref this){paramNames});");
            } else {
                writer.WriteLine($"{methodInfo.GetDeclarationStringWithoutPartial()} => {path}.{methodInfo.Name}({methodInfo.GetParameterNamesString()});");
            }
        }
    }

    private static void RenderInheritedPublicMethods(StructInfo inheritedStruct, string path, IndentedTextWriter writer) {
        foreach (MethodInfo methodInfo in inheritedStruct.ExtraInheritedStructInfo!.PublicMethods) {
            if (methodInfo.Name == "Ctor")
                continue;
            writer.WriteLine($"""/// <inheritdoc cref="{inheritedStruct.FullyQualifiedMetadataName}.{methodInfo.Name.Replace('<', '{').Replace('>', '}')}({methodInfo.GetParameterTypeStringForCref()})" />""");
            writer.WriteLine($"""/// <remarks>Method inherited from parent class <see cref="{inheritedStruct.FullyQualifiedMetadataName}">{inheritedStruct.Name}</see>.</remarks>""");
            writer.WriteLine("[global::System.Runtime.CompilerServices.MethodImplAttribute(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]");
            // public int SomeInheritedMethod(int param, int param2) => Path.To.Parent.SomeInheritedMethod(param, param2);
            writer.WriteLine($"{methodInfo.GetDeclarationStringWithoutPartial()} => {path}.{methodInfo.Name}({methodInfo.GetParameterNamesString()});");
        }
    }

    private static void RenderInheritedFixedSizeArrayAccessors(StructInfo inheritedStruct, string path, IndentedTextWriter writer) {
        foreach (FixedSizeArrayInfo fixedSizeArrayInfo in inheritedStruct.FixedSizeArrays) {
            writer.WriteLine($"""/// <inheritdoc cref="{inheritedStruct.FullyQualifiedMetadataName}.{fixedSizeArrayInfo.GetPublicFieldName()}" />""");
            writer.WriteLine($"""/// <remarks>Field inherited from parent class <see cref="{inheritedStruct.FullyQualifiedMetadataName}">{inheritedStruct.Name}</see>.</remarks>""");
            // [UnscopedRef] public Span<T> FieldName => Path.To.Parent_fieldName;
            writer.WriteLine($"[global::System.Diagnostics.CodeAnalysis.UnscopedRefAttribute] public Span<{fixedSizeArrayInfo.Type}> {fixedSizeArrayInfo.GetPublicFieldName()} => {path}.{fixedSizeArrayInfo.FieldName};");
            if (fixedSizeArrayInfo.IsString) {
                writer.WriteLine($"""/// <inheritdoc cref="{inheritedStruct.FullyQualifiedMetadataName}.{fixedSizeArrayInfo.GetPublicFieldName()}" />""");
                writer.WriteLine($"""/// <remarks>Field inherited from parent class <see cref="{inheritedStruct.FullyQualifiedMetadataName}">{inheritedStruct.Name}</see>.</remarks>""");
                writer.WriteLine($"public string {fixedSizeArrayInfo.GetPublicFieldName()}String");
                using (writer.WriteBlock()) {
                    if (fixedSizeArrayInfo.Type == "byte") {
                        // Encoding.UTF8.GetString(MemoryMarshal.CreateReadOnlySpanFromNullTerminated((byte*)Unsafe.AsPointer(ref _field[0])))
                        writer.WriteLine($"get => global::System.Text.Encoding.UTF8.GetString(global::System.Runtime.InteropServices.MemoryMarshal.CreateReadOnlySpanFromNullTerminated((byte*)global::System.Runtime.CompilerServices.Unsafe.AsPointer(ref {path}.{fixedSizeArrayInfo.FieldName}[0])));");
                        writer.WriteLine("set");
                        using (writer.WriteBlock()) {
                            writer.WriteLine($"if (global::System.Text.Encoding.UTF8.GetByteCount(value) > {fixedSizeArrayInfo.Size} - 1)");
                            using (writer.WriteBlock()) {
                                writer.WriteLine($"""InteropGenerator.Runtime.ThrowHelper.ThrowStringSizeTooLarge("{fixedSizeArrayInfo.GetPublicFieldName()}String", {fixedSizeArrayInfo.Size});""");
                            }
                            writer.WriteLine($"global::System.Text.Encoding.UTF8.GetBytes(value.AsSpan(), {path}.{fixedSizeArrayInfo.FieldName});");
                            writer.WriteLine($"{path}.{fixedSizeArrayInfo.FieldName}[{fixedSizeArrayInfo.Size - 1}] = 0;");
                        }
                    } else if (fixedSizeArrayInfo.Type == "char") {
                        writer.WriteLine($"get => new string({path}.{fixedSizeArrayInfo.FieldName});");
                        writer.WriteLine("set");
                        using (writer.WriteBlock()) {
                            writer.WriteLine($"if (value.Length > {fixedSizeArrayInfo.Size} - 1)");
                            using (writer.WriteBlock()) {
                                writer.WriteLine($"""InteropGenerator.Runtime.ThrowHelper.ThrowStringSizeTooLarge("{fixedSizeArrayInfo.GetPublicFieldName()}String", {fixedSizeArrayInfo.Size});""");
                            }
                            writer.WriteLine($"value.CopyTo({path}.{fixedSizeArrayInfo.FieldName});");
                            writer.WriteLine($"{path}.{fixedSizeArrayInfo.FieldName}[{fixedSizeArrayInfo.Size - 1}] = '\\0';");
                        }
                    }
                }
            }

        }
    }
}
