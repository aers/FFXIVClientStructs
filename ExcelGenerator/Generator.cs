using ExcelGenerator.CodeGen;
using ExcelGenerator.Schema;
using Lumina;
using Lumina.Data.Structs.Excel;
using System.Text;

namespace ExcelGenerator;

public sealed class Generator(string gamePath) : IDisposable {
    private readonly Deserializer _deserializer = new();
    private readonly GameData _gameData = new(gamePath);

    public void Dispose() => _gameData.Dispose();

    public static BaseGenerator CreateGeneratorForField(List<Field> fields, int fieldIndex, List<ExcelColumnDefinition> columns, int columnIndex, int startOffset) {
        var currentColumn = columns[columnIndex];
        if (currentColumn.Type >= ExcelColumnDataType.PackedBool0) {
            var count = columns[columnIndex..].TakeWhile(c => c.Offset == currentColumn.Offset).Count();
            return new BitFieldGenerator(fields.Slice(fieldIndex, count), columns, columnIndex, startOffset);
        }
        var field = fields[fieldIndex];
        if (field is ScalarField scalar)
            return new ScalarGenerator(scalar, columns, columnIndex, startOffset);
        if (field is ArrayField array)
            return new ArrayGenerator(array, columns, columnIndex, startOffset);
        if (field is StructField str)
            return new StructGenerator(str, columns, columnIndex, startOffset);
        throw new ArgumentException($"Unknown field type: {field} in column: 0x{currentColumn.Offset:X2} {currentColumn.Type}");
    }

    public string ProcessDefinition(string path, string name, string structName, string nameSpace) {
        if (!File.Exists(path)) {
            Console.WriteLine($" - schema {name} missing!");
            return string.Empty;
        }

        var sheet = _gameData.Excel.GetSheetRaw(name);
        if (sheet == null) {
            Console.WriteLine($" - sheet {name} no longer exists!");
            return string.Empty;
        }

        var schema = _deserializer.Deserialize(path);

        var builder = new StringBuilder();
        builder.AppendLine("// <auto-generated/>");
        builder.AppendLine($"namespace {nameSpace};");
        builder.AppendLine();

        var columns = sheet.Columns.ToList();
        columns.Sort((c1, c2) => Util.CalculateBitOffset(c1).CompareTo(Util.CalculateBitOffset(c2)));
        
        var generators = new List<BaseGenerator>();
        var colIndex = 0;

        try {
            for (var fieldIndex = 0; fieldIndex < schema.Fields.Count; fieldIndex++) {
                var offset = columns[colIndex].Offset;
                var fieldGenerator = CreateGeneratorForField(schema.Fields, fieldIndex, columns, colIndex, offset);
                generators.Add(fieldGenerator);
                colIndex += fieldGenerator.ConsumedColumnCount();
                fieldIndex += (fieldGenerator.ConsumedFieldCount() - 1);
            }
        } catch (ArgumentException ex) {
            Console.WriteLine(ex);
            return string.Empty;
        }

        if (generators.Any(c => c is ArrayGenerator or StructGenerator))
            builder.AppendLine("[GenerateInterop]");
        
        var structSize = columns[^1].Offset + Util.SizeOf(columns[^1].Type);
        structSize = (structSize + 3) & ~3; // align this up on 4

        builder.AppendLine($"[StructLayout(LayoutKind.Explicit, Size = 0x{structSize:X2})]");
        builder.AppendLine($"public unsafe partial struct {structName} {{");

        var fieldsBuilder = new StringBuilder();
        var structsBuilder = new StringBuilder();

        foreach (var generator in generators) {
            generator.WriteFields(fieldsBuilder);
            generator.WriteStructs(structsBuilder);
        }

        builder.AppendLine(Util.FixIndent(fieldsBuilder, 1).TrimEnd());
        if (structsBuilder.Length > 0) {
            builder.AppendLine();
            builder.AppendLine(Util.FixIndent(structsBuilder, 1).TrimEnd());
        }
        builder.AppendLine("}");
        return builder.ToString();
    }
}
