using System.Text;
using ExcelGenerator.CodeGen;
using ExcelGenerator.Schema;
using Lumina;
using Lumina.Data.Structs.Excel;

namespace ExcelGenerator;

public sealed class Generator(string? gamePath, string schemaPath) : IDisposable {
    private readonly Deserializer _deserializer = new();
    private readonly GameData? _gameData = string.IsNullOrEmpty(gamePath) ? null : new GameData(gamePath);
    private Dictionary<string, List<ExcelColumnDefinition>> _ymlColumnCache = [];

    public void Dispose() => _gameData?.Dispose();

    public static BaseGenerator CreateGeneratorForField(List<Field> fields, int fieldIndex, List<ExcelColumnDefinition> columns, int columnIndex, int startOffset) {
        var currentColumn = columns[columnIndex];
        if (currentColumn.Type >= ExcelColumnDataType.PackedBool0) {
            var count = columns[columnIndex..].TakeWhile(c => c.Offset == currentColumn.Offset).Count();
            return new BitFieldGenerator(fields.Slice(fieldIndex, count), columns, columnIndex, startOffset);
        }
        var field = fields[fieldIndex];
        return field switch {
            ScalarField => new ScalarGenerator(field, columns, columnIndex, startOffset),
            ArrayField => new ArrayGenerator(field, columns, columnIndex, startOffset),
            StructField => new StructGenerator(field, columns, columnIndex, startOffset),
            _ => throw new ArgumentException($"Unknown field type: {field} in column: 0x{currentColumn.Offset:X2} {currentColumn.Type}")
        };
    }

    private List<ExcelColumnDefinition>? GetColumns(string sheetName) {
        if (_gameData != null) {
            var sheet = _gameData.Excel.GetRawSheet(sheetName);
            return [.. sheet.Columns];
        }

        var columnsFile = Path.Combine(schemaPath, ".github", "columns.yml");
        if (_ymlColumnCache.Count == 0 && File.Exists(columnsFile))
            _ymlColumnCache = _deserializer.DeserializeColumns(columnsFile);

        return _ymlColumnCache.GetValueOrDefault(sheetName);
    }

    public string ProcessDefinition(string path, string name, string structName, string nameSpace) {
        if (!File.Exists(path)) {
            Console.WriteLine($" - schema {name} missing!");
            return string.Empty;
        }

        var columns = GetColumns(name);
        if (columns == null) {
            Console.WriteLine($" - sheet {name} no longer exists!");
            return string.Empty;
        }

        var schema = _deserializer.DeserializeSheet(path);

        var builder = new StringBuilder();
        builder.AppendLine("// <auto-generated/>");
        builder.AppendLine($"namespace {nameSpace};");
        builder.AppendLine();

        columns.Sort((c1, c2) => Util.CalculateBitOffset(c1).CompareTo(Util.CalculateBitOffset(c2)));

        var generators = new List<BaseGenerator>();
        var colIndex = 0;

        try {
            for (var fieldIndex = 0; fieldIndex < schema.Fields.Count; fieldIndex++) {
                var offset = columns[colIndex].Offset;
                var fieldGenerator = CreateGeneratorForField(schema.Fields, fieldIndex, columns, colIndex, offset);
                generators.Add(fieldGenerator);
                colIndex += fieldGenerator.ConsumedColumnCount();
                fieldIndex += (fieldGenerator.ConsumedFieldCount() - 1);
            }
        } catch (ArgumentException ex) {
            Console.WriteLine(ex);
            return string.Empty;
        }

        if (generators.Any(c => c is ArrayGenerator or StructGenerator))
            builder.AppendLine("[GenerateInterop]");

        var structSize = columns[^1].Offset + Util.SizeOf(columns[^1].Type);
        structSize = (structSize + 3) & ~3; // align this up on 4

        builder.AppendLine($"[StructLayout(LayoutKind.Explicit, Size = 0x{structSize:X2})]");
        builder.AppendLine($"public unsafe partial struct {structName} {{");

        var fieldsBuilder = new StringBuilder();
        var structsBuilder = new StringBuilder();

        foreach (var generator in generators) {
            generator.WriteFields(fieldsBuilder);
            generator.WriteStructs(structsBuilder);
        }

        builder.AppendLine(Util.FixIndent(fieldsBuilder, 1).TrimEnd());
        if (structsBuilder.Length > 0) {
            builder.AppendLine();
            builder.AppendLine(Util.FixIndent(structsBuilder, 1).TrimEnd());
        }
        builder.AppendLine("}");
        return builder.ToString();
    }
}
