using System.Collections.Immutable;
using FFXIVClientStructs.InteropGenerator;
using FFXIVClientStructs.InteropSourceGenerators.Extensions;
using FFXIVClientStructs.InteropSourceGenerators.Models;
using LanguageExt;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace FFXIVClientStructs.InteropSourceGenerators;

[Generator]
internal sealed class AgentGettersGenerator : IIncrementalGenerator {
    private const string AgentAttributeName = "FFXIVClientStructs.Attributes.AgentAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context) {
        IncrementalValuesProvider<(Validation<DiagnosticInfo, StructInfo> StructInfo,
            Validation<DiagnosticInfo, AgentInfo> AgentInfo)> structAndAgentInfos =
            context.SyntaxProvider
                .ForAttributeWithMetadataName(
                    AgentAttributeName,
                    static (node, _) => node is StructDeclarationSyntax {
                        AttributeLists.Count: > 0
                    },
                    static (context, _) => {
                        StructDeclarationSyntax structSyntax = (StructDeclarationSyntax)context.TargetNode;
                        INamedTypeSymbol symbol = (INamedTypeSymbol)context.TargetSymbol;
                        return (Struct: StructInfo.GetFromSyntax(structSyntax),
                            Info: AgentInfo.GetFromRoslyn(structSyntax, symbol));
                    });

        // make sure caching is working
        IncrementalValuesProvider<Validation<DiagnosticInfo, StructWithAgentInfos>> structWithAgentInfos =
            structAndAgentInfos.Select(static (item, _) =>
                (item.StructInfo, item.AgentInfo).Apply(static (si, ai) =>
                    new StructWithAgentInfos(si, ai))
            );

        context.RegisterSourceOutput(structWithAgentInfos, (sourceContext, item) => {
            item.Match(
                Fail: diagnosticInfos => {
                    diagnosticInfos.Iter(dInfo => sourceContext.ReportDiagnostic(dInfo.ToDiagnostic()));
                },
                Succ: structWithAgentInfo => {
                    sourceContext.AddSource(structWithAgentInfo.GetFileName(), structWithAgentInfo.RenderSource());
                });
        });

        IncrementalValueProvider<ImmutableArray<Validation<DiagnosticInfo, StructWithAgentInfos>>>
            collectedStructs = structWithAgentInfos.Collect();

        context.RegisterSourceOutput(collectedStructs,
            (sourceContext, structs) => {
                sourceContext.AddSource("AgentModule.AgentGetters.g.cs", BuildAgentModuleAgentGettersSource(structs));
            });
    }

    private static string BuildAgentModuleAgentGettersSource(
        ImmutableArray<Validation<DiagnosticInfo, StructWithAgentInfos>> structInfos) {
        IndentedStringBuilder builder = new();

        builder.AppendLine("// <auto-generated/>");
        builder.AppendLine();

        builder.AppendLine("namespace FFXIVClientStructs.FFXIV.Client.UI.Agent;");
        builder.AppendLine();

        builder.AppendLine("public unsafe partial struct AgentModule");
        builder.AppendLine("{");
        builder.Indent();

        structInfos.Iter(siv =>
            siv.IfSuccess(structWithAgentInfo => structWithAgentInfo.RenderAgentGetter(builder)));

        builder.DecrementIndent();
        builder.AppendLine("}");

        return builder.ToString();
    }

    internal sealed record AgentInfo(StructInfo StructInfo, uint AgentId) {
        public static Validation<DiagnosticInfo, AgentInfo> GetFromRoslyn(
            StructDeclarationSyntax structSyntax, INamedTypeSymbol namedTypeSymbol) {
            Validation<DiagnosticInfo, StructInfo> validStructInfo =
                StructInfo.GetFromSyntax(structSyntax);

            Option<AttributeData> agentAttribute = namedTypeSymbol.GetFirstAttributeDataByTypeName(AgentAttributeName);

            Validation<DiagnosticInfo, uint> validAgentId =
                agentAttribute.GetValidAttributeArgument<uint>("ID", 0, AgentAttributeName, namedTypeSymbol);

            return (validStructInfo, validAgentId).Apply((structInfo, agentId) =>
                new AgentInfo(structInfo, agentId));
        }
    }

    private sealed record StructWithAgentInfos
        (StructInfo StructInfo, AgentInfo AgentInfo) {
        public string RenderSource() {
            IndentedStringBuilder builder = new();

            StructInfo.RenderStart(builder);

            builder.AppendLine();
            builder.AppendLine($"public static {StructInfo.Name}* Instance() => ({StructInfo.Name}*)AgentModule.Instance()->GetAgentByInternalId((AgentId){AgentInfo.AgentId});");
            builder.AppendLine();

            StructInfo.RenderEnd(builder);

            return builder.ToString();
        }

        public string GetFileName() {
            return $"{StructInfo.Name}.InstanceGetter.g.cs";
        }

        public void RenderAgentGetter(IndentedStringBuilder builder) {
            builder.AppendLine($"public {StructInfo.Name}* Get{StructInfo.Name}() => ({StructInfo.Name}*)GetAgentByInternalId((AgentId){AgentInfo.AgentId});");
        }
    }
}
